import hashlib

# Parameters for secp256k1
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240
Gy = 32670510020758816978083085130507043184471273380659243275938904335757337461467

def modinv(x, m=P):
    return pow(x, m-2, m)

def point_add(P1, P2):
    if P1 is None: return P2
    if P2 is None: return P1
    (x1,y1), (x2,y2) = P1, P2
    if x1 == x2 and y1 != y2: return None
    if x1 == x2:
        m = (3*x1*x1) * modinv(2*y1) % P
    else:
        m = (y2-y1) * modinv(x2-x1) % P
    x3 = (m*m - x1 - x2) % P
    y3 = (m*(x1-x3)-y1) % P
    return (x3,y3)

def scalar_mult(k, P= (Gx,Gy)):
    R = None
    Q = P
    while k:
        if k & 1:
            R = point_add(R, Q)
        Q = point_add(Q, Q)
        k >>= 1
    return R

def tagged_hash(tag, msg):
    t = hashlib.sha256(tag.encode()).digest()
    return hashlib.sha256(t+t+msg).digest()

def int_from_bytes(b): return int.from_bytes(b, "big")
def bytes_from_int(x): return x.to_bytes(32, "big")

def bip340_verify(msg, pubkey, sig):
    if len(pubkey) != 32 or len(sig) != 64:
        return False

    px = int_from_bytes(pubkey)
    if px >= P: return False

    # Recover y from x (must be even)
    y_sq = (px*px*px + 7) % P
    y = pow(y_sq, (P+1)//4, P)
    if (y*y - y_sq) % P != 0: return False
    if y & 1: y = P-y
    P_point = (px, y)

    r = int_from_bytes(sig[:32])
    s = int_from_bytes(sig[32:])
    if r >= P or s >= N: return False

    e = int_from_bytes(tagged_hash("BIP0340/challenge",
                sig[:32] + pubkey + msg)) % N

    R = point_add(scalar_mult(s), scalar_mult(N-e, P_point))
    if R is None or (R[0] % P) != r or (R[1] & 1):
        return False
    return True
